--------------------------------------------------------------------------------
TODO
--------------------------------------------------------------------------------
#define ZEN_LIB_IMPLEMENTATION
#define ZEN_GLFW_IMPLEMENTATION
#define ZEN_GLEZ_IMPLEMENTATION
#define STB_IMAGE_IMPLEMENTATION
#define STB_RECT_PACK_IMPLEMENTATION
#define STB_TRUETYPE_IMPLEMENTATION


#include <sys/stat.h>
#include "glad/glad.h"
#include "GLFW/glfw3.h"
#include "stb_image.h"


#include "stb_rect_pack.h"
#include "stb_truetype.h"


#include "zen/zen_lib.h"
#include "zen/zen_glfw.h"
#include "zen/zen_glez.h"


ZGLFW *glfw;
uint8 *image;
uint8 *buf;
int buf_width;
int buf_height;


typedef struct frame_buffer {
 

	Vector3_t vertices[6];
	Vector2_t tex_coords[6];

	Matrix4x4_t projection;

	GLuint vao_id;
	GLuint vbo_ids[2];
	GLuint tex_id;
	GLuint sampler;
	GLuint program_id;
	GLint projection_uniform;
	GLint sampler_location;
	GLint vertex_attribute;
	GLint tex_attribute;


} frame_buffer;
static frame_buffer *fb;

//const char *filename = "../Inconsolata-Regular.ttf";
//const char *filename = "../Roboto-Regular.ttf";
//const char *filename = "../FreePixel.ttf";
//const char *filename = "/home/twright/Qt5.7.0/Examples/Qt-5.7/quick/text/fonts/content/fonts/tarzeau_ocr_a.ttf";
const char *filename = "/home/twright/innoven/java/idea-IC-163.12024.16/plugins/android/lib/layoutlib/data/fonts/DroidSansMono.ttf";
const int pixel_size = 18;
stbtt_fontinfo font;


void init_stbtt() {

	//
	// setup stb_ttf here...
	struct stat st;

	GB_ASSERT_MSG(stat(filename, &st) == 0, "Can't stat file size for %s", filename);
	usize size = st.st_size;
	FILE *fontfile = fopen(filename, "rb");
	GB_ASSERT_NOT_NULL(fontfile);

	uint8 *data = ZEN_CALLOC(uint8, size);
	usize bytes_read = fread(data, 1, size, fontfile);
	GB_ASSERT_MSG(bytes_read == size, "Didn't read enough bytes?");
	fclose(fontfile);


	GB_ASSERT(stbtt_InitFont(&font, data, 0));


	// create testing buffer
   float scale = stbtt_ScaleForPixelHeight(&font, pixel_size);
	int x0, y0, x1, y1;
	stbtt_GetFontBoundingBox(&font, &x0, &y0, &x1, &y1);
	zout("bounding box: (%f, %f), (%f, %f)", x0 * scale, y0 * scale, x1 * scale, y1 * scale);
	zout("width, height: %f, %f", (x1 - x0) * scale, (y1 - y0) * scale);
	buf_width = (int)((x1 - x0) * scale + 1);
	buf_height = (int)((y1 - y0) * scale + 1);
	zout("iw, ih: %d, %d", buf_width, buf_height);
	image = ZEN_CALLOC(uint8, 1024 * 768);	
	buf = ZEN_CALLOC(uint8, buf_width * buf_height);
	GB_ASSERT_NOT_NULL(image);	


}


void init_framebuffer() {

	fb = ZEN_CALLOC(frame_buffer, 1);
	GB_ASSERT_NOT_NULL(fb);


	const char *vs = \
		"#version 440 core\n"
		"uniform mat4 proj_mat;\n"
		"layout (location = 0) in vec3 v_position;\n"
		"layout (location = 1) in vec2 v_tex_coord;\n"
		"out vec2 f_tex_coord;\n"
		"void main(void) {\n"
		"	gl_Position = proj_mat * vec4(v_position, 1.0f);\n"
		"	f_tex_coord = v_tex_coord;\n"
		"}\n";

	const char *fs = \
		"#version 440 core\n"
		"in vec2 f_tex_coord;\n"
		"layout (binding = 0) uniform sampler2D u_tex;\n"
		"out vec4 o_color;\n"
		"void main(void) {\n"
		"	float alpha = texture2D(u_tex, f_tex_coord).r;\n"
		"  o_color = vec4(1.0, 1.0, 1.0, 1.0) * alpha; \n"
		"}\n";

	fb->projection = Matrix4x4();

	fb->program_id = zglez_create_shader_program(vs, fs);
	glUseProgram(fb->program_id);
	fb->projection_uniform = glGetUniformLocation(fb->program_id, "proj_mat");
	fb->sampler_location = glGetUniformLocation(fb->program_id, "u_tex");
	fb->vertex_attribute = 0;
	fb->tex_attribute = 1;


	// Generate
	glGenVertexArrays(1, &fb->vao_id);
	glGenBuffers(2, fb->vbo_ids);

	glBindVertexArray(fb->vao_id);
	glEnableVertexAttribArray(fb->vertex_attribute);
	glEnableVertexAttribArray(fb->tex_attribute);

	// Vertex buffer
	glBindBuffer(GL_ARRAY_BUFFER, fb->vbo_ids[0]);
	glVertexAttribPointer(fb->vertex_attribute, 3, GL_FLOAT, GL_FALSE, 0, zen_offset(0));
	glBufferData(GL_ARRAY_BUFFER, sizeof(fb->vertices), fb->vertices, GL_DYNAMIC_DRAW);

	glBindBuffer(GL_ARRAY_BUFFER, fb->vbo_ids[1]);
	glVertexAttribPointer(fb->tex_attribute, 2, GL_FLOAT, GL_FALSE, 0, zen_offset(0));
	glBufferData(GL_ARRAY_BUFFER, sizeof(fb->tex_coords), fb->tex_coords, GL_DYNAMIC_DRAW);

	ZGLEZ_CHECK_ERROR();

	// Cleanup
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindVertexArray(0);
	glUseProgram(0);


	glGenTextures(1, &fb->tex_id);
	glBindTexture(GL_TEXTURE_2D, fb->tex_id);


	glGenSamplers(1, &fb->sampler);
	glSamplerParameteri(fb->sampler, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glSamplerParameteri(fb->sampler, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glSamplerParameteri(fb->sampler, GL_TEXTURE_WRAP_S,     GL_REPEAT);
	glSamplerParameteri(fb->sampler, GL_TEXTURE_WRAP_T,     GL_REPEAT);


	glTexImage2D( GL_TEXTURE_2D, 0, GL_RED, 1024, 768, 0, GL_RED, GL_UNSIGNED_BYTE, NULL);


	glBindTexture(GL_TEXTURE_2D, 0);


	Vector3_t tlv = Vector3(-1.0f, -1.0f, 0.0f);
	Vector3_t blv = Vector3(-1.0f, 1.0f, 0.0f);
	Vector3_t brv = Vector3(1.0f, 1.0f, 0.0f);
	Vector3_t trv = Vector3(1.0f, -1.0f, 0.0f);

	Vector2_t tlt = Vector2(0.0f, 1.0f);
	Vector2_t blt = Vector2(0.0f, 0.0f);
	Vector2_t brt = Vector2(1.0f, 0.0f);
	Vector2_t trt = Vector2(1.0f, 1.0f);

	// setup verticies and tex coords
	fb->vertices[0] = tlv;
	fb->vertices[1] = blv;
	fb->vertices[2] = trv;

	fb->vertices[3] = trv;
	fb->vertices[4] = blv;
	fb->vertices[5] = brv;

	fb->tex_coords[0] = tlt;
	fb->tex_coords[1] = blt;
	fb->tex_coords[2] = trt;

	fb->tex_coords[3] = trt;
	fb->tex_coords[4] = blt;
	fb->tex_coords[5] = brt;

}


void update_framebuffer() {

	float xpos = 100;
   float scale = stbtt_ScaleForPixelHeight(&font, pixel_size);

	// clear the image
	memset(image, 0, 1024 * 768);
	const char *string = "Hello World! AVAV ";
	int ch = 0;

	while(string[ch]) {
		// leftSideBearing is the offset from the current horizontal position to the left edge of the character
		// advanceWidth is the offset from the current horizontal position to the next horizontal position
		//   these are expressed in unscaled coordinates
		int advance, lsb;
		stbtt_GetCodepointHMetrics(&font, string[ch], &advance, &lsb);

		float x_shift = xpos - (float) floor(xpos);
		//zout("\"%c\" =  adv: %f, lsb: %f, x-shift: %f", string[ch], advance * scale, lsb * scale, x_shift);

		// get the bbox of the bitmap centered around the glyph origin; so the
		// bitmap width is ix1-ix0, height is iy1-iy0, and location to place
		// the bitmap top left is (leftSideBearing*scale,iy0).
		// (Note that the bitmap uses y-increases-down, but the shape uses
		// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)

		int x0, y0, x1, y1;
		float scale_x = scale;
		float scale_y = scale;
		float shift_x = x_shift;
		float shift_y = 0.0f;
		stbtt_GetCodepointBitmapBoxSubpixel(
			&font, string[ch], scale_x, scale_y, shift_x, shift_y, &x0, &y0, &x1, &y1
		);

		// TODO: before we do any of this we have to learn how
		// to render to a RenderBuffer or BufferObjects, and then
		// draw that as a texture on the screen

		//this isn't right - stride not right and
		//data should be one byte per pixel, not 4 bytes per pixel

		int ypos = 100;
		int stride = 1024;
		//ziout(y0);
		//ziout(y1);

		// can we put the glyph into our temp buffer?
		// then copy the temp into the real?
		int row = ypos + y0;
		int col = xpos;
		int image_offset = row * stride + col;
      stbtt_MakeCodepointBitmapSubpixel(
			&font, image + image_offset, x1 - x0, y1 - y0, stride, 
			scale_x, scale_y, shift_x, shift_y, string[ch]
		);

		//zout("\tBBSP: (%d, %d), (%d, %d)", x0, y0, x1, y1);

		xpos += (advance * scale);
		if (string[ch+1]) {
			xpos += scale * stbtt_GetCodepointKernAdvance(&font, string[ch], string[ch+1]);
		}
		//zfout(xpos);
		ch++;

	}

}


void render_framebuffer() {

	glUseProgram(fb->program_id);
	glBindVertexArray(fb->vao_id);

	glUniformMatrix4fv(fb->projection_uniform, 1, GL_FALSE, fb->projection.m);

	glActiveTexture(GL_TEXTURE0);
	glUniform1i(fb->sampler_location, 0);
	glBindSampler(0, fb->sampler);

	glBindTexture(GL_TEXTURE_2D, fb->tex_id);

	GLint xoffset = 0;
	GLint yoffset = 0;
	GLsizei width = 1024;
	GLsizei height = 768;
	GLenum format = GL_RED;
	GLenum type = GL_UNSIGNED_BYTE;
	void *data = cast(void *)image;
	glTexSubImage2D(GL_TEXTURE_2D, 0, xoffset, yoffset, width, height, format, type, data);


	glBindBuffer(GL_ARRAY_BUFFER, fb->vbo_ids[0]);
	glBufferSubData(GL_ARRAY_BUFFER, 0, 6 * sizeof(Vector3_t), fb->vertices);

	glBindBuffer(GL_ARRAY_BUFFER, fb->vbo_ids[1]);
	glBufferSubData(GL_ARRAY_BUFFER, 0, 6 * sizeof(Vector2_t), fb->tex_coords);

	glDrawArrays(GL_TRIANGLES, 0, 6);

	ZGLEZ_CHECK_ERROR();

	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindVertexArray(0);
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, 0);
	glBindSampler(0, 0);
	glUseProgram(0);


}


int main(int argc, char *argv[]) {

	// simple example of writing to a off-screen buffer
	//

	glfw = zglfw_create("frame_buffer", 1024, 768);
	zglfw_init(glfw);
	glViewport(0, 0, 1024, 768);
	init_framebuffer();
	init_stbtt();

	bool enable = true;
	glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);

	zglfw_show_window(glfw);
	while (zglfw_is_running(glfw)) {
		if (ZGLFW_KEY_DOWN_ONCE(glfw, SPACE)) {
			enable = !enable;
		}
		if (enable) {
			glEnable(GL_BLEND);
		} else {
			glDisable(GL_BLEND);
		}
		zglfw_begin(glfw);
		glfw->should_close = ZGLFW_KEY_DOWN(glfw, ESCAPE);

		update_framebuffer();
		render_framebuffer();

		zglfw_end(glfw);
	}


	zglfw_quit(glfw);
	zglfw_destroy(glfw);

	return 0;
}
