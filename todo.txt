--------------------------------------------------------------------------------
TODO
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
sdl_mixer algorithm
--------------------------------------------------------------------------------


/* The internal format for an audio chunk */
typedef struct Mix_Chunk {
    int allocated; // 0 if not malloc, 1 if malloc (free or don't free)
    Uint8 *abuf; // DUMB(abuf = audio_buffer) the audio data in memory
    Uint32 alen; // DUMB(alen = audio_length) length of the buffer
    Uint8 volume; // per sample volume       /* Per-sample volume, 0-128 */
} Mix_Chunk;


static struct _Mix_Channel {
    Mix_Chunk *chunk; // the actual data
    int playing; // set to Mix_Chunk.alen
    int paused;  // 0 or 1
    Uint8 *samples; // current pointer into chunk data
    int volume;
    int looping;
    int tag;
    Uint32 expire;
    Uint32 start_time;
    Mix_Fading fading;
    int fade_volume;
    int fade_volume_reset;
    Uint32 fade_length;
    Uint32 ticks_fade;
    effect_info *effects;
} *mix_channel = NULL;


NOTE - 
int Mix_OpenAudio(int frequency, Uint16 format, int nchannels, int chunksize)
This is where SDL_mixer actually sets up the low-level audio stuff


------------------------------------------
LOAD WAV FILE
------------------------------------------
Mix_Chunk *Mix_LoadWAV_RW(SDL_RWops *src, int freesrc)

This is the part of mixer that actually loads the wave file.
A little confusing at because the load-wave file returns
an SDL_AudioSpec pointer, and fill another SDL_AudioSpec with
the format of the loaded file.  The returned pointer is just used
for a null check to see if the load worked

This does a conversion on the loaded data if
format, channels, or freq do not match.  Hmmmm.  Channel count.  
Missed that.

------------------------------------------
The convert thing is kind of dumb, but I think I get it.
------------------------------------------


SDL_AudioCVT cvt;

int result = SDL_BuildAudioCVT(&cvt, src_fmt, src_channels, src_freq,
dest_fmt, dest_channels, dest_freq);

if (result == 1) Ready for conversion
if (result == 0) No conversion needed
if (result < 0) Error code. call SDL_GetError()

cvt.len = channel.alen;
cvt.buf = (Uint8 *) SDL_malloc(cvt.len * cvt.len_mult);
SDL_memcpy(cvt.buf, channel.abuf, channel.alen);

result = SDL_ConvertAudio(&cvt);
if (result == 0) success
if (result < 0) SDL_GetError();

// Now cvt.buf has converted data of length cvt.len_cvt
free(channel.abuf);
channel.abuf = cvt.buf
channel.alen = cvt.len_cvt;

------------------------------------------
------------------------------------------


------------------------------------------
How does the mixing actually work,
and why not use it?
------------------------------------------
    case AUDIO_U16LSB:
        {
            Uint16 src1, src2;
            int dst_sample;
            const int max_audioval = 0xFFFF;

            len /= 2;
            while (len--) {
                src1 = ((src[1]) << 8 | src[0]);
                ADJUST_VOLUME(src1, volume);
                src2 = ((dst[1]) << 8 | dst[0]);
                src += 2;
                dst_sample = src1 + src2;
                if (dst_sample > max_audioval) {
                    dst_sample = max_audioval;
                }
                dst[0] = dst_sample & 0xFF;
                dst_sample >>= 8;
                dst[1] = dst_sample & 0xFF;
                dst += 2;
            }
        }
        break;

------------------------------------------
------------------------------------------


Maybe some more code review on the conversion stuff here...
    /* Build the audio converter and create conversion buffers */
    if ( wavespec.format != mixer.format ||
         wavespec.channels != mixer.channels ||
         wavespec.freq != mixer.freq ) {
        if ( SDL_BuildAudioCVT(&wavecvt,
                wavespec.format, wavespec.channels, wavespec.freq,
                mixer.format, mixer.channels, mixer.freq) < 0 ) {
            SDL_free(chunk->abuf);
            SDL_free(chunk);
            return(NULL);
        }


		  /*
				I question if we even need the sample size here.  
				Isn't the chunk->alen the size of the buffer?
				Id chunk->alen is not bytes, the I guess, but
				how is it not bytes?
		  */
        samplesize = ((wavespec.format & 0xFF)/8)*wavespec.channels;
		  // The wavecvt.len = number of samples (1024) * bytes per sample * num
		  // of channels
        wavecvt.len = chunk->alen & ~(samplesize-1);
        wavecvt.buf = (Uint8 *)SDL_calloc(1, wavecvt.len*wavecvt.len_mult);
        if ( wavecvt.buf == NULL ) {
            SDL_SetError("Out of memory");
            SDL_free(chunk->abuf);
            SDL_free(chunk);
            return(NULL);
        }
        SDL_memcpy(wavecvt.buf, chunk->abuf, chunk->alen);
        SDL_free(chunk->abuf);

        /* Run the audio converter */
        if ( SDL_ConvertAudio(&wavecvt) < 0 ) {
            SDL_free(wavecvt.buf);
            SDL_free(chunk);
            return(NULL);
        }

        chunk->abuf = wavecvt.buf;
        chunk->alen = wavecvt.len_cvt;
    }

------------------------------------------
QUESTIONS...
------------------------------------------
How the fuck does streaming from files work,
and do we even care?


? Is the playing value the number of samples left?
? What is the channel.chuck for anyway? Seems like an internal 
	audio chunk format,  i.e. the actually data pointer in the
	channel.
BUT - there is also a Uint8 *samples in the channel?  What is
the difference?

? How to actually mix current samples into output buffer?


clear the buffer with silence
loop through each channel
if paused, drive on, else

	if channel should expire
		stop channel
	
	else if channel is fading
		if channel done fading
			set not fading
			restore volume
			if channel fading out
				stop channel
		else
			if channel fading out
				fade down
			else
				fade up	

	if channel still playing
		while channel has more samples and pos smaller than output buffer length
		
			calculate samples remaining in channel
			calc volume as channel volume time channel chuck volume			
			make sure at most output buffer length or remaining samples
			process samples with any effects
			mix processed samples into current output buffer
			free effect samples if it was malloc




--------------------------------------------------------------------------------
audio Guy Somberg
--------------------------------------------------------------------------------


Output = A + B

Output = sum of all sounds

Embarrassingly Vectorizable
	Just use SSMD, and it's basically free (Very cheap)

The audio mix is the hard part!  How you combine the sounds that are playing.

An easy way to deal with this is to lower the volume:

* Gain reduction
* Sound Cones
* 3D distance attenuation
* Ducking

Mix States/Sound Moods/Mixer Snapshots

A big chucnk of audio technology revolves around not playing sounds.
* max playbacks
* Stream limits
* Virtualized sound sorces


Walter Murch
Rule of two and a half
One person, sync footsteps,
Two people, sync
Two and 1/2 - Nothing in sync, just a bunch of footsteps


Audio Mix
* Let the most important sounds shine


dB = Decibels
* 1/10 of a Bel
* What is a Bel?  Doesn't matter

* Most important fact: 6dB = Double
	-6dB == 1/2 volume
	-12dB == 1/4 volume
	+18dB == 8x volume


Important source code!!!

float dBToVolume(float dB) {
	return powf(10.0f, 0.05f * dB);
}

float VolumeTodB(float volume) {
	return 20.0f * log10f(volume);
}



// Bootstrap an aduio engine
zen_audio.h

class AudioEngine {

public:

	static void Init();
	static void Update();
	static void Shutdown();

	void loadSound(string soundName, bool b3d=true, bool bLooping=false, bool bStream=false);
	void unloadSound(string soundName);
	void set3dListenerAndOrientation(Vec3 position, Vec3 look, Vec3 up);
	void playSound(string soundName, Vec3 pos={0,0,0}, float volumedB = 0.0f);
	void stopChannel(int channelId);
	void stopAllChannels();
	void setChannel3dPosition(int channelId, Vec3 position);
	void setChannelVolume(int channelId, float volumedB);
	bool isPlaying(int channelId);

};


struct Implementation {

	Implementation();
	~Implementation();

	void update();

	FMOD::System *system;

	int nextChannelId;

	typedef map<string, FMOD::Sound *> SoundMap;
	typedef map<int, FMOD::Channel *> ChannelMap;

	SoundMap sounds;
	ChannelMap channels;

};


void Implementation::update() {
	vector<ChannelMap::iterator> stoppedChannels;

	for(auto it = channels.begin(), itEnd = channels.end(); it != itEnd; ++it) {
		bool isPlaying = false;
		it->second->isPlaying(&isPlaying);
		if(!isPlaying) {
			stoppedChannels.push_back(it);
		}
	}

	for(auto &it : stoppedChannels) {
		channels.erase(it);
	}

	system->Update();
}


////////////////////////////////////////////////////////////////////////////////

Implementation *impl = NULL;

void AudioEngine::Init() {
	impl = new Implementation;
}

void AudioEngine::Update() {
	impl->update();
}

void AudioEngine::Shutdown() {
	delete impl;
}

void AudioEngine::loadSound(string name, bool b3d, bool looping, bool stream) {

	auto foundIt = impl->sounds.find(name);
	if (foundIt != impl->sounds.end()) {
		// already loaded
		return;
	}

	FMOD_MODE mode = FMOD_DEFAULT;
	mode |= b3d ? FMOD_3D : FMOD_2D;
	mode |= looping ? FMOD_LOOP_NORMAL : FMOD_LOOP_OFF;
	mode |= stream ? FMOD_CREATESTREAM : FMOD_CREATECOMPRESSEDSAMPLE;
	FMOD::Sound *sound = NULL;
	impl->system->createSound(name, mode, NULL, &sound);

	if (sound) {
		impl->sounds[name] = sound;
	}
}

void AudioEngine::unloadSound(string name) {

	auto foundIt = impl->sounds.find(name);
	if (foundIt == impl->sounds.end())
		return; // not loaded

	foundIt->second->release();
	impl->sounds.erase(foundIt);

}

int AudioEngine::playSound(string name, Vec3 position, float volumedB) {

	int channelId = impl->nextChannelId++;
	auto foundIt = impl->sounds.find(name);
	if (foundIt == impl->sounds.end()) {
		loadSound(name);
		foundIt = impl->sound.find(name);
		if (foundIt == impl->sounds.end())
			return channelId; // Important
	}

	FMOD::Channel *channel = NULL;
	impl->system->playSound(FMOD_CHAMMEL_FREE, foundIt->second, true,
&channel); // true here to not play sound - could pop
	if (channel) {
		FMOD_VECTOR pos = VectorToFmod(position);
		channel->set3DAttributes(&pos, NULL);
		channel->setVolume(dBToVolume(volumedB));
		channel->setPaused(false); // now we unpause
		impl->channels[channelId] = channel;
	}
	return channelId;
}

