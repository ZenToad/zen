-------------------------------------------------------
-- Sprite testing
-------------------------------------------------------
#define ZEN_LIB_IMPLEMENTATION 
#define ZEN_SDL_IMPLEMENTATION
#define ZEN_GLEZ_IMPLEMENTATION
#define STB_IMAGE_IMPLEMENTATION


#include <stdio.h>
#include <stdlib.h>
#include <signal.h>


#include "glad/glad.h"
#include <SDL.h>
#include "stb_image.h"
 
  
#include "zen/zen_lib.h"
#include "zen/zen_sdl.h"
#include "zen/zen_glez.h"


typedef union Quad3_t {

	Vector3_t v[4];
	struct {
		Vector3_t top_left;
		Vector3_t bottom_left;
		Vector3_t bottom_right;
		Vector3_t top_right;
	};

} Quad3_t;


Quad3_t Quad3(float x, float y, float w, float h) {

	Quad3_t quad;
	quad.top_left = Vector3(x, y, 1.0f);
	quad.bottom_left = Vector3(x, y + h, 1.0f);
	quad.bottom_right = Vector3(x + w, y + h, 1.0f);
	quad.top_right = Vector3(x + w, y, 1.0f);
	return quad;

}

typedef union Quad2_t {

	Vector2_t v[4];
	struct {
		Vector2_t top_left;
		Vector2_t bottom_left;
		Vector2_t bottom_right;
		Vector2_t top_right;
	};

} Quad2_t;


Quad2_t Quad2(float x, float y, float w, float h) {

	Quad2_t quad;
	quad.top_left = Vector2(x, y);
	quad.bottom_left = Vector2(x, y + h);
	quad.bottom_right = Vector2(x + w, y + h);
	quad.top_right = Vector2(x + w, y);
	return quad;

}


typedef struct Sprite {

	const char *name;
	Quad3_t quad;
	Quad3_t quad_copy;
	Quad2_t texture_coords[64];
	int sprite_index;

	Transform2d_t transform;

} Sprite;


Sprite *create_sprite(const char *name, const char *filename) {

	int w = 0, h = 0;
	int flip = 0;
	if (!zglez_load_texture_from_file(name, filename, &w, &h, flip)) {
		return NULL;
	}

	float cellw = 1.0f / 8.0f;
	float cellh = 1.0f / 8.0f;
	Sprite *sprite = ZEN_CALLOC(Sprite, 1);
	sprite->name = name;
	sprite->sprite_index = 0;

	sprite->transform = Transform2d(Vector2(0.0f, 0.0f), 0.0f, Vector2(1.0f, 1.0f));

	sprite->quad = Quad3(-0.5f, +0.5f, 1.0f, -1.0f);
	for (int i = 0; i < 64; ++i) {
		int x = i % 8;
		int y = i / 8;
		sprite->texture_coords[i] = Quad2(cellw * x, cellh * y, cellw, cellh);
	}

	return sprite;
}


#define KEY_DOWN(SDL,KEY) SDL->keys[SDL_SCANCODE_##KEY]

SDL_Zen *sdl;


void draw_sprite(Sprite *sprite) {

	Matrix3x3_t mat = Matrix3x3();
	mat = mat * scale(sprite->transform.scale);
	mat = mat * rotate2D(sprite->transform.rotation);
	mat = mat * translate(sprite->transform.position);


	for (int i = 0; i < 4; ++i) {
		sprite->quad_copy.v[i] = mat * sprite->quad.v[i];
	}

	int index = sprite->sprite_index;
	zglez_texture_quad(sprite->name, sprite->quad_copy.v, sprite->texture_coords[index].v);

}

 
int main(int argc, char *argv[]) {

	sdl = SDL_Zen_Create();

	sdl->window_title = (char *)"SDL_Testing again...";
	sdl->window_width = 1024;
	sdl->window_height = 1024;
	sdl->major_version = 4;
	sdl->minor_version = 4;
	sdl->window_background = 0xFF444444;

	SDL_Zen_Init(sdl);
	zglez_init();

	ziout((SDL_BUTTON_LEFT));
	ziout((SDL_BUTTON_MIDDLE));
	ziout((SDL_BUTTON_RIGHT));

	Vector3_t poly[] = {
		Vector3(0.0f, 0.0f, 0.0f),
		Vector3(0.0f, 0.5f, 0.0f),
		Vector3(-0.5f, -0.5f, 0.0f),
		Vector3(0.5f, -0.5f, 0.0f),
	};

	Vector3_t poly2[] = {
		Vector3(0.0f, 0.0f, 0.0f),
		Vector3(0.0f, 0.5f, 0.0f),
		Vector3(-0.5f, -0.5f, 0.0f),
		Vector3(0.5f, -0.5f, 0.0f),
		Vector3(0.0f, 0.5f, 0.0f),
	};


	Sprite *sprite = create_sprite("poop", "./poopypoo.png");
	GB_ASSERT_NOT_NULL(sprite);
	sprite->transform.position = Vector2(-.7f, 0.7f);
	sprite->transform.scale = Vector2(0.25f, 0.25f);

	double change = 1.0f / 1.0f;
	double delta_change = 0.0f;

	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	while (SDL_Zen_IsRunning(sdl)) {
		SDL_Zen_Begin(sdl);

		if (MOUSE_DOWN(sdl, RIGHT)) zout("Right down");
		if (MOUSE_DOWN_ONCE(sdl, LEFT)) zout("LEFT down");
		sdl->should_close = KEY_DOWN(sdl, ESCAPE);

		sprite->transform.rotation += M_PI * sdl->delta_time * 0.1;

		zglez_draw_line(Vector3(-0.5f, 0.0f, 0.0f), Vector3(0.5f, 0.0f, 0.0f), COLORF_GREEN);
		zglez_fill_circle(Vector3(0.0f, 0.0f, 0.0f), 0.5f, COLORF_RED);
		zglez_fill_polygon(poly2, COLORF_BLUE, 5);
			
		delta_change += sdl->delta_time;
		while (delta_change >= change) {
			delta_change -= change;
			sprite->sprite_index++;
			if (sprite->sprite_index > 63)
				sprite->sprite_index = 0;
		}
		draw_sprite(sprite);

		zglez_flush();
		SDL_Zen_End(sdl);
	}

	SDL_Zen_Quit(sdl);
	zglez_quit();

	SDL_Zen_Destroy(sdl);

	return 0;

}
-------------------------------------------------------
-- Sprite testing
-------------------------------------------------------


this isn't working atm...
void lets_try_hashmap() {

	Hashmap *map = Hashmap_create(NULL, NULL);

	Hashmap_set(map, gb_make_string("key1"), gb_make_string("value1"));
	Hashmap_set(map, gb_make_string("key1"), gb_make_string("value1"));
	Hashmap_set(map, gb_make_string("key1"), gb_make_string("value1"));
	Hashmap_set(map, gb_make_string("key1"), gb_make_string("value1"));
	Hashmap_set(map, gb_make_string("key1"), gb_make_string("value1"));
	Hashmap_set(map, gb_make_string("key1"), gb_make_string("value1"));
	Hashmap_set(map, gb_make_string("key1"), gb_make_string("value1"));
	Hashmap_set(map, gb_make_string("key1"), gb_make_string("value1"));
	Hashmap_set(map, gb_make_string("key1"), gb_make_string("value1"));
	Hashmap_set(map, gb_make_string("key1"), gb_make_string("value1"));
	Hashmap_set(map, gb_make_string("key1"), gb_make_string("value1"));
	Hashmap_set(map, gb_make_string("key1"), gb_make_string("value1"));

	//zout("key1: %s", Hashmap_get(map, "key1"));
	//zout("key3: %s", Hashmap_get(map, "key3"));


	//char k[2] = {0};
	//char v[2] = {0};
	//for (int i = 0; i < 1024 * 1024; ++i) {
		//gbString key = gb_make_string(0);
		//gbString value = gb_make_string(0);
		//int n = 3; //rand() % 8 + 1;
		//int min = 33, max = 7;
		//for (int j = 0; j < n; ++j) {
			//k[0] = (rand() % max) + min;
			//v[0] = (rand() % max) + min;
			//key = gb_append_cstring(key, k);
			//value = gb_append_cstring(value, v);
		//}
		//Hashmap_set(map, key, value);
		////zout("key: %s, value: %s", key, value);
	//}

	zout("\nprint the map...\n");
	Hashmap_traverse(map, print_map);

	Hashmap_destroy(map);

}

--------------------------------------------------------------------------------
TODO
--------------------------------------------------------------------------------

* fix the math library to add operator overloading and 
  references if __cplusplus is defined

* Update the box_2d debug drawing to use the zen_gl.h stuff

* Update zen_gl.h to use the better caching from the box_2d
  debug example

* Can we add some C++ stuff to the libraries to make them
  more usefull without taking away from the C part?


audio Guy Somberg
--------------------------------------

Output = A + B

Output = sum of all sounds

Embarrassingly Vectorizable
	Just use SSMD, and it's basically free (Very cheap)

The audio mix is the hard part!  How you combine the sounds that are playing.

An easy way to deal with this is to lower the volume:

* Gain reduction
* Sound Cones
* 3D distance attenuation
* Ducking

Mix States/Sound Moods/Mixer Snapshots

A big chucnk of audio technology revolves around not playing sounds.
* max playbacks
* Stream limits
* Virtualized sound sorces


Walter Murch
Rule of two and a half
One person, sync footsteps,
Two people, sync
Two and 1/2 - Nothing in sync, just a bunch of footsteps


Audio Mix
* Let the most important sounds shine


dB = Decibels
* 1/10 of a Bel
* What is a Bel?  Doesn't matter

* Most important fact: 6dB = Double
	-6dB == 1/2 volume
	-12dB == 1/4 volume
	+18dB == 8x volume


Important source code!!!

float dBToVolume(float dB) {
	return powf(10.0f, 0.05f * dB);
}

float VolumeTodB(float volume) {
	return 20.0f * log10f(volume);
}



// Bootstrap an aduio engine
zen_audio.h

class AudioEngine {

public:

	static void Init();
	static void Update();
	static void Shutdown();

	void loadSound(string soundName, bool b3d=true, bool bLooping=false, bool bStream=false);
	void unloadSound(string soundName);
	void set3dListenerAndOrientation(Vec3 position, Vec3 look, Vec3 up);
	void playSound(string soundName, Vec3 pos={0,0,0}, float volumedB = 0.0f);
	void stopChannel(int channelId);
	void stopAllChannels();
	void setChannel3dPosition(int channelId, Vec3 position);
	void setChannelVolume(int channelId, float volumedB);
	bool isPlaying(int channelId);

};


struct Implementation {

	Implementation();
	~Implementation();

	void update();

	FMOD::System *system;

	int nextChannelId;

	typedef map<string, FMOD::Sound *> SoundMap;
	typedef map<int, FMOD::Channel *> ChannelMap;

	SoundMap sounds;
	ChannelMap channels;

};


void Implementation::update() {
	vector<ChannelMap::iterator> stoppedChannels;

	for(auto it = channels.begin(), itEnd = channels.end(); it != itEnd; ++it) {
		bool isPlaying = false;
		it->second->isPlaying(&isPlaying);
		if(!isPlaying) {
			stoppedChannels.push_back(it);
		}
	}

	for(auto &it : stoppedChannels) {
		channels.erase(it);
	}

	system->Update();
}


////////////////////////////////////////////////////////////////////////////////

Implementation *impl = NULL;

void AudioEngine::Init() {
	impl = new Implementation;
}

void AudioEngine::Update() {
	impl->update();
}

void AudioEngine::Shutdown() {
	delete impl;
}

void AudioEngine::loadSound(string name, bool b3d, bool looping, bool stream) {

	auto foundIt = impl->sounds.find(name);
	if (foundIt != impl->sounds.end()) {
		// already loaded
		return;
	}

	FMOD_MODE mode = FMOD_DEFAULT;
	mode |= b3d ? FMOD_3D : FMOD_2D;
	mode |= looping ? FMOD_LOOP_NORMAL : FMOD_LOOP_OFF;
	mode |= stream ? FMOD_CREATESTREAM : FMOD_CREATECOMPRESSEDSAMPLE;
	FMOD::Sound *sound = NULL;
	impl->system->createSound(name, mode, NULL, &sound);

	if (sound) {
		impl->sounds[name] = sound;
	}
}

void AudioEngine::unloadSound(string name) {

	auto foundIt = impl->sounds.find(name);
	if (foundIt == impl->sounds.end())
		return; // not loaded

	foundIt->second->release();
	impl->sounds.erase(foundIt);

}

int AudioEngine::playSound(string name, Vec3 position, float volumedB) {

	int channelId = impl->nextChannelId++;
	auto foundIt = impl->sounds.find(name);
	if (foundIt == impl->sounds.end()) {
		loadSound(name);
		foundIt = impl->sound.find(name);
		if (foundIt == impl->sounds.end())
			return channelId; // Important
	}

	FMOD::Channel *channel = NULL;
	impl->system->playSound(FMOD_CHAMMEL_FREE, foundIt->second, true,
&channel); // true here to not play sound - could pop
	if (channel) {
		FMOD_VECTOR pos = VectorToFmod(position);
		channel->set3DAttributes(&pos, NULL);
		channel->setVolume(dBToVolume(volumedB));
		channel->setPaused(false); // now we unpause
		impl->channels[channelId] = channel;
	}
	return channelId;
}

